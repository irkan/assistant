/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/model/ayla.glb -o src/components/character/Ayla.tsx -r public 
*/

import * as THREE from 'three'
import React, { useEffect, useImperativeHandle, forwardRef, useState, useRef } from 'react'
import { useGraph, ThreeElements, useFrame } from '@react-three/fiber'
import { useGLTF, useAnimations } from '@react-three/drei'
import { GLTF, SkeletonUtils } from 'three-stdlib'
import { MixamoAnimationLoader } from '../../utils/mixamoAnimation'

type ActionName = 'Armature|6577333224704_TempMotion' | 'Key|6577333224704_TempMotion' | 'Key.002|6577333224704_TempMotion' | 'Key.001|6577333224704_TempMotion' | 'Key.003|6577333224704_TempMotion' | 'Greeting'

export interface MorphTargetData {
  morphTarget: string;
  weight: string;
}

export interface AylaModelRef {
  updateMorphTargets: (targets: MorphTargetData[]) => void;
  playGreetingAnimation: () => Promise<void>;
}

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}

type GLTFResult = GLTF & {
  nodes: {
    Bang: THREE.SkinnedMesh
    Bun: THREE.SkinnedMesh
    Hair_Base_1: THREE.SkinnedMesh
    Hair_Base_2: THREE.SkinnedMesh
    High_Heels: THREE.SkinnedMesh
    Knee_length_skirt: THREE.SkinnedMesh
    Real_Hair: THREE.SkinnedMesh
    Rolled_sleeves_shirt: THREE.SkinnedMesh
    Underwear_Bottoms: THREE.SkinnedMesh
    CC_Base_Body_1: THREE.SkinnedMesh
    CC_Base_Body_2: THREE.SkinnedMesh // Target Mesh
    CC_Base_Body_3: THREE.SkinnedMesh
    CC_Base_Body_4: THREE.SkinnedMesh
    CC_Base_Body_5: THREE.SkinnedMesh
    CC_Base_Body_6: THREE.SkinnedMesh
    CC_Base_Body_7: THREE.SkinnedMesh
    CC_Base_Body_8: THREE.SkinnedMesh
    CC_Base_Body_9: THREE.SkinnedMesh // Target Mesh
    CC_Base_Body_10: THREE.SkinnedMesh
    CC_Base_Body_11: THREE.SkinnedMesh
    CC_Base_Body_12: THREE.SkinnedMesh
    CC_Base_Body_13: THREE.SkinnedMesh
    CC_Base_EyeOcclusion_1: THREE.SkinnedMesh
    CC_Base_EyeOcclusion_2: THREE.SkinnedMesh
    CC_Base_TearLine_1: THREE.SkinnedMesh
    CC_Base_TearLine_2: THREE.SkinnedMesh
    Female_Angled_1: THREE.SkinnedMesh
    Female_Angled_2: THREE.SkinnedMesh
    CC_Base_BoneRoot: THREE.Bone
  }
  materials: {
    ['Hair_Transparency.003']: THREE.MeshStandardMaterial
    ['Hair_Transparency.001']: THREE.MeshStandardMaterial
    Hair_Transparency: THREE.MeshStandardMaterial
    Scalp_Transparency: THREE.MeshStandardMaterial
    High_Heels: THREE.MeshStandardMaterial
    Knee_length_skirt: THREE.MeshStandardMaterial
    ['Hair_Transparency.002']: THREE.MeshStandardMaterial
    Rolled_sleeves_shirt: THREE.MeshStandardMaterial
    Underwear_Bottoms: THREE.MeshStandardMaterial
    Std_Tongue: THREE.MeshStandardMaterial
    Std_Skin_Head: THREE.MeshStandardMaterial
    Std_Skin_Body: THREE.MeshStandardMaterial
    Std_Skin_Arm: THREE.MeshStandardMaterial
    Std_Skin_Leg: THREE.MeshStandardMaterial
    Std_Nails: THREE.MeshStandardMaterial
    Std_Eyelash: THREE.MeshStandardMaterial
    Std_Upper_Teeth: THREE.MeshStandardMaterial
    Std_Lower_Teeth: THREE.MeshStandardMaterial
    Std_Eye_R: THREE.MeshStandardMaterial
    Std_Cornea_R: THREE.MeshStandardMaterial
    Std_Eye_L: THREE.MeshStandardMaterial
    Std_Cornea_L: THREE.MeshStandardMaterial
    Std_Eye_Occlusion_R: THREE.MeshStandardMaterial
    Std_Eye_Occlusion_L: THREE.MeshStandardMaterial
    Std_Tearline_R: THREE.MeshStandardMaterial
    Std_Tearline_L: THREE.MeshStandardMaterial
    Female_Angled_Transparency: THREE.MeshStandardMaterial
    Female_Angled_Base_Transparency: THREE.MeshStandardMaterial
  }
  animations: GLTFAction[]
}

export const Model = forwardRef<AylaModelRef, ThreeElements['group']>((props, ref) => {
  const group = React.useRef<THREE.Group>(null!)
  const { scene, animations: characterAnimations } = useGLTF('/model/ayla.glb')
  const { animations: motionAnimations } = useGLTF('/model/motion.glb')
  
  // State for loaded Mixamo animations
  const [greetingAnimation, setGreetingAnimation] = useState<THREE.AnimationClip | null>(null)
  const [isGreetingLoaded, setIsGreetingLoaded] = useState(false)
  
  const animations = React.useMemo(() => 
    [...characterAnimations, ...motionAnimations, ...(greetingAnimation ? [greetingAnimation] : [])], 
    [characterAnimations, motionAnimations, greetingAnimation]
  )
  
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone) as unknown as Pick<GLTFResult, 'nodes' | 'materials'>
  const { actions, mixer } = useAnimations(animations, group)
  
  // Animation state
  const [currentAnimation, setCurrentAnimation] = useState<string>('Armature|6577333224704_TempMotion')
  const [isPlayingGreeting, setIsPlayingGreeting] = useState(false)
  
  // Load Mixamo greeting animation with bone mapping
  useEffect(() => {
    const loadGreetingAnimation = async () => {
      try {
        console.log('ðŸŽ­ Loading Mixamo greeting animation...');
        const loader = new MixamoAnimationLoader();
        const result = await loader.loadMixamoAnimation('/model/greeting.fbx');
        
        if (result.success) {
          console.log('ðŸŽ­ Mixamo greeting animation loaded successfully');
          result.animationClip.name = 'Greeting';
          setGreetingAnimation(result.animationClip);
          setIsGreetingLoaded(true);
        } else {
          console.error('ðŸŽ­ Failed to load Mixamo greeting animation:', result.message);
        }
      } catch (error) {
        console.error('ðŸŽ­ Error loading Mixamo greeting animation:', error);
      }
    };
    
    loadGreetingAnimation();
  }, []);
  
  // GÃ¶z qÄ±rpma Ã¼Ã§Ã¼n state'lÉ™r
  const blinkTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const [blinkState, setBlinkState] = useState<'open' | 'closing' | 'closed' | 'opening'>('open')
  const [blinkProgress, setBlinkProgress] = useState(0)
  const nextBlinkTimeRef = useRef(0)
  
  // GÃ¶z qÄ±rpmaÄŸÄ± planlaÅŸdÄ±r
  const scheduleNextBlink = () => {
    if (blinkTimeoutRef.current) {
      clearTimeout(blinkTimeoutRef.current);
    }
    
    // Random olaraq 10-15 saniyÉ™ arasÄ±nda bir gÃ¶z qÄ±rpma
    const nextBlinkDelay = 10000 + Math.random() * 5000;
    nextBlinkTimeRef.current = Date.now() + nextBlinkDelay;
    
    blinkTimeoutRef.current = setTimeout(() => {
      // GÃ¶z qÄ±rpma baÅŸlat
      setBlinkState('closing');
      setBlinkProgress(0);
    }, nextBlinkDelay);
  };

  // GÃ¶z qÄ±rpma Ã¼Ã§Ã¼n morph targetlÉ™rini yenilÉ™mÉ™k
  const updateEyeBlinkMorphs = (weight: number) => {
    // GÃ¶z qapaqlarÄ± (CC_Base_Body_2) Ã¼Ã§Ã¼n morph target
    const headMesh = nodes['CC_Base_Body_2'] as THREE.SkinnedMesh;
    if (headMesh && headMesh.morphTargetDictionary && headMesh.morphTargetInfluences) {
      // Sol gÃ¶z
      const blinkLeftIndex = headMesh.morphTargetDictionary['Eye_Blink_L'];
      if (blinkLeftIndex !== undefined) {
        headMesh.morphTargetInfluences[blinkLeftIndex] = weight;
      }
      
      // SaÄŸ gÃ¶z
      const blinkRightIndex = headMesh.morphTargetDictionary['Eye_Blink_R'];
      if (blinkRightIndex !== undefined) {
        headMesh.morphTargetInfluences[blinkRightIndex] = weight;
      }
    }
    
    // KirpiklÉ™r (CC_Base_Body_7) Ã¼Ã§Ã¼n morph target
    const eyelashMesh = nodes['CC_Base_Body_7'] as THREE.SkinnedMesh;
    if (eyelashMesh && eyelashMesh.morphTargetDictionary && eyelashMesh.morphTargetInfluences) {
      // Sol kirpik
      const blinkLeftIndex = eyelashMesh.morphTargetDictionary['Eye_Blink_L'];
      if (blinkLeftIndex !== undefined) {
        eyelashMesh.morphTargetInfluences[blinkLeftIndex] = weight;
      }
      
      // SaÄŸ kirpik
      const blinkRightIndex = eyelashMesh.morphTargetDictionary['Eye_Blink_R'];
      if (blinkRightIndex !== undefined) {
        eyelashMesh.morphTargetInfluences[blinkRightIndex] = weight;
      }
    }
  };

  // HÉ™r frame'dÉ™ gÃ¶z qÄ±rpma animasiyasÄ±nÄ± yenilÉ™mÉ™k Ã¼Ã§Ã¼n
  useFrame((_state: any, delta: number) => {
    // GÃ¶z qÄ±rpma animasiyasÄ±
    if (blinkState === 'closing') {
      // GÃ¶zÃ¼ baÄŸlama (0.1 saniyÉ™)
      setBlinkProgress(blinkProgress + delta * 10);
      
      // Transition
      updateEyeBlinkMorphs(Math.min(blinkProgress, 1));
      
      if (blinkProgress >= 1) {
        setBlinkState('closed');
        setBlinkProgress(0);
      }
    } 
    else if (blinkState === 'closed') {
      // GÃ¶zÃ¼n baÄŸlÄ± qalma mÃ¼ddÉ™ti (0.05 saniyÉ™)
      setBlinkProgress(blinkProgress + delta * 20);
      
      if (blinkProgress >= 1) {
        setBlinkState('opening');
        setBlinkProgress(0);
      }
    }
    else if (blinkState === 'opening') {
      // GÃ¶zÃ¼ aÃ§ma (0.15 saniyÉ™)
      setBlinkProgress(blinkProgress + delta * 6.67);
      
      // Transition
      updateEyeBlinkMorphs(Math.max(1 - blinkProgress, 0));
      
      if (blinkProgress >= 1) {
        setBlinkState('open');
        setBlinkProgress(0);
        // NÃ¶vbÉ™ti gÃ¶z qÄ±rpmanÄ± planlaÅŸdÄ±r
        scheduleNextBlink();
      }
    }
  });
  
  useImperativeHandle(ref, () => ({
    updateMorphTargets: (targets: MorphTargetData[]) => {
      const targetMeshNames = ['CC_Base_Body_2', 'CC_Base_Body_9'] as const; // Apply to both meshes

      targetMeshNames.forEach(meshName => {
        const meshNode = nodes[meshName] as THREE.SkinnedMesh;

        if (meshNode && meshNode.morphTargetDictionary && meshNode.morphTargetInfluences) {
          // Optional: Reset all other morphs on this mesh to 0 first
          // This ensures that only the specified morphs are active.
          // If you want morphs to be additive without this, comment out the next loop.
          for (let i = 0; i < meshNode.morphTargetInfluences.length; i++) {
            meshNode.morphTargetInfluences[i] = 0;
          }

          targets.forEach(targetData => {
            const morphTargetIndex = meshNode.morphTargetDictionary![targetData.morphTarget];
            if (morphTargetIndex !== undefined) {
              const weightValue = parseFloat(targetData.weight);
              if (!isNaN(weightValue)) {
                meshNode.morphTargetInfluences![morphTargetIndex] = weightValue;
              } else {
                console.warn(`[Ayla.tsx] Invalid weight value for morph target "${targetData.morphTarget}" on mesh "${meshName}": ${targetData.weight}`);
              }
            } else {
              console.warn(`[Ayla.tsx] Morph target "${targetData.morphTarget}" not found in dictionary for mesh "${meshName}". Available targets:`, Object.keys(meshNode.morphTargetDictionary!));
            }
          });
        } else {
          let errorMsg = `[Ayla.tsx] Failed to update morph targets for mesh "${meshName}".`;
          if (!meshNode) {
              errorMsg += ` Mesh node not found. Available nodes: ${Object.keys(nodes).join(', ')}.`;
          } else if (!meshNode.morphTargetDictionary) {
              errorMsg += ` morphTargetDictionary not found.`;
          } else if (!meshNode.morphTargetInfluences) {
              errorMsg += ` morphTargetInfluences not found.`;
          }
          console.warn(errorMsg);
        }
      });
    },
    playGreetingAnimation: async () => {
      if (!actions.Greeting || !isGreetingLoaded) {
        console.error('ðŸŽ­ Greeting animation not available or not loaded yet');
        return;
      }
      
      try {
        console.log('ðŸŽ­ Starting greeting animation...');
        
        // Save current position and scale
        const savedPosition = group.current.position.clone();
        const savedScale = group.current.scale.clone();
        console.log('ðŸŽ­ Saved position:', savedPosition, 'scale:', savedScale);
        
        // Fade out current animation
        if (actions[currentAnimation]) {
          actions[currentAnimation]?.fadeOut(0.5);
        }
        
        // Play greeting animation
        actions.Greeting.reset().fadeIn(0.5).play();
        setCurrentAnimation('Greeting');
        setIsPlayingGreeting(true);
        
        // Ensure position and scale remain constant during animation
        const maintainTransform = () => {
          if (group.current) {
            group.current.position.copy(savedPosition);
            group.current.scale.copy(savedScale);
          }
        };
        
        // Set up interval to maintain transform
        const transformInterval = setInterval(maintainTransform, 16); // ~60fps
        
        // Return to idle animation after 5 seconds
        setTimeout(() => {
          // Clear transform maintenance
          clearInterval(transformInterval);
          setIsPlayingGreeting(false);
          
          // Restore position and scale one final time
          if (group.current) {
            group.current.position.copy(savedPosition);
            group.current.scale.copy(savedScale);
          }
          
          if (actions.Greeting) {
            actions.Greeting?.fadeOut(0.5);
          }
          if (actions['Armature|6577333224704_TempMotion']) {
            actions['Armature|6577333224704_TempMotion']?.reset().fadeIn(0.5).play();
            setCurrentAnimation('Armature|6577333224704_TempMotion');
          }
          console.log('ðŸŽ­ Greeting animation completed, returning to idle');
        }, 5000);
        
      } catch (error) {
        console.error('ðŸŽ­ Error playing greeting animation:', error);
      }
    }
  }));

  // Handle animation changes
  useEffect(() => {
    if (actions[currentAnimation]) {
      actions[currentAnimation]?.reset().fadeIn(0.5).play();
      return () => {
        if (actions[currentAnimation]) {
          actions[currentAnimation]?.fadeOut(0.5);
        }
      };
    }
  }, [currentAnimation, actions]);
  
  useEffect(() => {
    const animationNames = Object.keys(actions)
    
    if (animationNames.length > 0) {
      const firstAnimation = actions[animationNames[0]]
      if (firstAnimation && typeof firstAnimation.fadeIn === 'function') { 
        firstAnimation.reset().fadeIn(0.5).play()
      }
    }
    
    // Ä°lk gÃ¶z qÄ±rpmanÄ± planlaÅŸdÄ±r
    scheduleNextBlink();
    
    
    
    return () => {
      Object.values(actions).forEach(action => {
        if (action && typeof action.fadeOut === 'function') {
          action.fadeOut(0.5)
        }
      })
      if (blinkTimeoutRef.current) {
        clearTimeout(blinkTimeoutRef.current);
      }
    }
  }, [actions, mixer])
  
  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="Armature" scale={0.01}>
          <primitive object={nodes.CC_Base_BoneRoot} />
          <skinnedMesh name="Bang" geometry={nodes.Bang.geometry} material={materials['Hair_Transparency.003']} skeleton={nodes.Bang.skeleton} />
          <skinnedMesh name="Bun" geometry={nodes.Bun.geometry} material={materials['Hair_Transparency.001']} skeleton={nodes.Bun.skeleton} />
          <group name="Hair_Base">
            <skinnedMesh name="Hair_Base_1" geometry={nodes.Hair_Base_1.geometry} material={materials.Hair_Transparency} skeleton={nodes.Hair_Base_1.skeleton} />
            <skinnedMesh name="Hair_Base_2" geometry={nodes.Hair_Base_2.geometry} material={materials.Scalp_Transparency} skeleton={nodes.Hair_Base_2.skeleton} />
          </group>
          <skinnedMesh name="High_Heels" geometry={nodes.High_Heels.geometry} material={materials.High_Heels} skeleton={nodes.High_Heels.skeleton} />
          <skinnedMesh name="Knee_length_skirt" geometry={nodes.Knee_length_skirt.geometry} material={materials.Knee_length_skirt} skeleton={nodes.Knee_length_skirt.skeleton} />
          <skinnedMesh name="Real_Hair" geometry={nodes.Real_Hair.geometry} material={materials['Hair_Transparency.002']} skeleton={nodes.Real_Hair.skeleton} />
          <skinnedMesh name="Rolled_sleeves_shirt" geometry={nodes.Rolled_sleeves_shirt.geometry} material={materials.Rolled_sleeves_shirt} skeleton={nodes.Rolled_sleeves_shirt.skeleton} />
          <skinnedMesh name="Underwear_Bottoms" geometry={nodes.Underwear_Bottoms.geometry} material={materials.Underwear_Bottoms} skeleton={nodes.Underwear_Bottoms.skeleton} />
          <group name="CC_Base_Body">
            <skinnedMesh name="CC_Base_Body_1" geometry={nodes.CC_Base_Body_1.geometry} material={materials.Std_Tongue} skeleton={nodes.CC_Base_Body_1.skeleton} morphTargetDictionary={nodes.CC_Base_Body_1.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_1.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_2" geometry={nodes.CC_Base_Body_2.geometry} material={materials.Std_Skin_Head} skeleton={nodes.CC_Base_Body_2.skeleton} morphTargetDictionary={nodes.CC_Base_Body_2.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_2.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_3" geometry={nodes.CC_Base_Body_3.geometry} material={materials.Std_Skin_Body} skeleton={nodes.CC_Base_Body_3.skeleton} morphTargetDictionary={nodes.CC_Base_Body_3.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_3.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_4" geometry={nodes.CC_Base_Body_4.geometry} material={materials.Std_Skin_Arm} skeleton={nodes.CC_Base_Body_4.skeleton} morphTargetDictionary={nodes.CC_Base_Body_4.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_4.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_5" geometry={nodes.CC_Base_Body_5.geometry} material={materials.Std_Skin_Leg} skeleton={nodes.CC_Base_Body_5.skeleton} morphTargetDictionary={nodes.CC_Base_Body_5.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_5.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_6" geometry={nodes.CC_Base_Body_6.geometry} material={materials.Std_Nails} skeleton={nodes.CC_Base_Body_6.skeleton} morphTargetDictionary={nodes.CC_Base_Body_6.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_6.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_7" geometry={nodes.CC_Base_Body_7.geometry} material={materials.Std_Eyelash} skeleton={nodes.CC_Base_Body_7.skeleton} morphTargetDictionary={nodes.CC_Base_Body_7.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_7.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_8" geometry={nodes.CC_Base_Body_8.geometry} material={materials.Std_Upper_Teeth} skeleton={nodes.CC_Base_Body_8.skeleton} morphTargetDictionary={nodes.CC_Base_Body_8.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_8.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_9" geometry={nodes.CC_Base_Body_9.geometry} material={materials.Std_Lower_Teeth} skeleton={nodes.CC_Base_Body_9.skeleton} morphTargetDictionary={nodes.CC_Base_Body_9.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_9.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_10" geometry={nodes.CC_Base_Body_10.geometry} material={materials.Std_Eye_R} skeleton={nodes.CC_Base_Body_10.skeleton} morphTargetDictionary={nodes.CC_Base_Body_10.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_10.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_11" geometry={nodes.CC_Base_Body_11.geometry} material={materials.Std_Cornea_R} skeleton={nodes.CC_Base_Body_11.skeleton} morphTargetDictionary={nodes.CC_Base_Body_11.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_11.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_12" geometry={nodes.CC_Base_Body_12.geometry} material={materials.Std_Eye_L} skeleton={nodes.CC_Base_Body_12.skeleton} morphTargetDictionary={nodes.CC_Base_Body_12.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_12.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_13" geometry={nodes.CC_Base_Body_13.geometry} material={materials.Std_Cornea_L} skeleton={nodes.CC_Base_Body_13.skeleton} morphTargetDictionary={nodes.CC_Base_Body_13.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_13.morphTargetInfluences} />
          </group>
          <group name="CC_Base_EyeOcclusion">
            <skinnedMesh name="CC_Base_EyeOcclusion_1" geometry={nodes.CC_Base_EyeOcclusion_1.geometry} material={materials.Std_Eye_Occlusion_R} skeleton={nodes.CC_Base_EyeOcclusion_1.skeleton} morphTargetDictionary={nodes.CC_Base_EyeOcclusion_1.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_EyeOcclusion_1.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_EyeOcclusion_2" geometry={nodes.CC_Base_EyeOcclusion_2.geometry} material={materials.Std_Eye_Occlusion_L} skeleton={nodes.CC_Base_EyeOcclusion_2.skeleton} morphTargetDictionary={nodes.CC_Base_EyeOcclusion_2.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_EyeOcclusion_2.morphTargetInfluences} />
          </group>
          <group name="CC_Base_TearLine">
            <skinnedMesh name="CC_Base_TearLine_1" geometry={nodes.CC_Base_TearLine_1.geometry} material={materials.Std_Tearline_R} skeleton={nodes.CC_Base_TearLine_1.skeleton} morphTargetDictionary={nodes.CC_Base_TearLine_1.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_TearLine_1.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_TearLine_2" geometry={nodes.CC_Base_TearLine_2.geometry} material={materials.Std_Tearline_L} skeleton={nodes.CC_Base_TearLine_2.skeleton} morphTargetDictionary={nodes.CC_Base_TearLine_2.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_TearLine_2.morphTargetInfluences} />
          </group>
          <group name="Female_Angled">
            <skinnedMesh name="Female_Angled_1" geometry={nodes.Female_Angled_1.geometry} material={materials.Female_Angled_Transparency} skeleton={nodes.Female_Angled_1.skeleton} morphTargetDictionary={nodes.Female_Angled_1.morphTargetDictionary} morphTargetInfluences={nodes.Female_Angled_1.morphTargetInfluences} />
            <skinnedMesh name="Female_Angled_2" geometry={nodes.Female_Angled_2.geometry} material={materials.Female_Angled_Base_Transparency} skeleton={nodes.Female_Angled_2.skeleton} morphTargetDictionary={nodes.Female_Angled_2.morphTargetDictionary} morphTargetInfluences={nodes.Female_Angled_2.morphTargetInfluences} />
          </group>
        </group>
      </group>
    </group>
  )
})

Model.displayName = 'AylaModel'

useGLTF.preload('/model/ayla.glb')
useGLTF.preload('/model/motion.glb') 